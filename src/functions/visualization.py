"""
/***************************************************************************
 PlateauStatisticsVisualizationPlugin
                                 A QGIS plugin
 Urban Structure Assessment Dashboard
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-08-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Author
        email                : mail
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from __future__ import annotations

import os
import re
import xml.etree.ElementTree as ET
from distutils.util import strtobool # pylint: disable=deprecated-module

import numpy as np
import pandas as pd
from PyQt5.QtCore import QTimer # pylint: disable=import-error, no-name-in-module
from PyQt5.QtWidgets import QScrollArea, QVBoxLayout, QWidget # pylint: disable=import-error, no-name-in-module
from qgis.PyQt.QtCore import QCoreApplication, Qt, pyqtSignal # pylint: disable=import-error
from qgis.PyQt.QtWidgets import (QComboBox, QDockWidget, # pylint: disable=import-error
                                 QGroupBox, QLabel, QPushButton)

import matplotlib.pyplot as plt
from matplotlib import colors as mcolors
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.ticker import FuncFormatter

from ..utils.LayersColoring import LayersColoring


plt.rcParams['font.family'] = "MS Gothic"
_config_dir = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), '../config'
)
_config_file = os.path.join(_config_dir, 'VisualizationConfig.xml')
_datalist_file = os.path.join(_config_dir, 'DataListConfig.xml')
_default_colors = list(
    dict(mcolors.TABLEAU_COLORS, **mcolors.CSS4_COLORS).keys()
)

def safe_find(element, tag, default=''):
    """
    XML内の要素を安全に検索し、見つからない場合はデフォルト値を返す

    :param element: XMLの親要素
    :type element: xml.etree.ElementTree.Element
    :param tag: 検索するタグ名
    :type tag: str
    :param default: 見つからない場合のデフォルト値
    :type default: str

    :return: 検索されたタグの値、またはデフォルト値
    :rtype: str
    """
    found = element.find(tag)
    return found.text if found is not None else default


def load_config(datalist_file, config_file):
    """
    XMLファイルから設定を読み込む

    :param datalist_file: データリストXMLファイルのパス
    :type datalist_file: str
    :param config_file: 設定XMLファイルのパス
    :type config_file: str

    :return: データ項目、年リスト、データセット
    :rtype: tuple[dict, list, dict]
    """
    dataList_tree = ET.parse(datalist_file)
    dataList_root = dataList_tree.getroot()

    data_items = {}
    for item in dataList_root.find('data_items').findall('item'):
        main_label = item.find('label').text
        sub_items = {}
        sub_items_elem = item.find('sub_items')
        if sub_items_elem is not None:
            for sub_item in sub_items_elem.findall('sub_item'):
                sub_label = sub_item.find('label').text
                sub_value = sub_item.find('value').text
                sub_items[sub_label] = sub_value
        data_items[main_label] = sub_items

    years = [year.text for year in dataList_root.find('years')]

    tree = ET.parse(config_file)
    root = tree.getroot()

    datasets = {}
    for dataset in root.find('datasets'):
        item_val = dataset.find('item_val').text

        datalist = []
        for data in dataset.find('datalist'):
            colors = []
            try:
                colors = (
                    safe_find(data, 'color', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            x_labels = []
            try:
                x_labels = (
                    safe_find(data, 'x_label', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            legends = []
            try:
                legends = (
                    safe_find(data, 'legends', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            datalist.append({
                'title': safe_find(data, 'title', 'No Name'),
                'path': safe_find(data, 'path'),
                'type': safe_find(data, 'type', 'Percentbar'),
                'addline': safe_find(data, 'addline', 'false'),
                'x': safe_find(data, 'x'),
                'y': safe_find(data, 'y', '').split(','),
                'change_rates': safe_find(data, 'change_rates'),
                'bar_label_rotate': safe_find(
                    data, 'bar_label_rotate', 'false'
                ),
                'color': colors,
                'label_type': safe_find(data,'label_type', 'edge'),
                'label_format': safe_find(data,'label_format', '1'),
                'x_labels': x_labels,
                'is_display_legend': safe_find(
                    data, 'is_display_legend', 'false'
                ),
                'is_display_bar_label': safe_find(
                    data, 'is_display_bar_label', 'true'
                ),
                'x_name': safe_find(data, 'x_name', ''),
                'legends': legends
            })
        if item_val not in datasets:
            datasets[item_val] = {}
        datasets[item_val] = datalist

    return data_items, years, datasets


def format_number_1f(x):
    """
    小数点以下1桁で数値をフォーマットする

    :param x: フォーマットする数値
    :type x: float

    :return: フォーマットされた数値
    :rtype: str
    """
    return f'{x:.1f}'


def format_number_2f(x):
    """
    小数点以下2桁で数値をフォーマットする

    :param x: フォーマットする数値
    :type x: float

    :return: フォーマットされた数値
    :rtype: str
    """
    return f'{x:.2f}'


def format_number_hundred(x):
    """
    桁区切りで数値をフォーマットする

    :param x: フォーマットする数値
    :type x: int

    :return: フォーマットされた数値
    :rtype: str
    """
    return f'{x:,}'


def format_axis(x, _):
    """
    軸ラベルをフォーマットする

    :param x: 軸ラベルの値
    :type x: float
    :param _: 使用されない引数
    :type _: Any

    :return: フォーマットされた軸ラベル
    :rtype: str
    """
    return f'{x:.0f}'


def is_1d_list(lst):
    """
    指定されたリストが1次元リストかどうかを確認する。

    :param lst: チェックするリスト
    :type lst: list

    :return: リストが1次元の場合はTrue、そうでない場合はFalse
    :rtype: bool
    """
    if not lst:
        return True

    return all(
        not isinstance(item, (list, tuple, np.ndarray, pd.Series))
        for item in lst
    )


class ControlDock(QDockWidget):
    """
    可視化を制御するためのdockwidget
    
    属性:
        plotSignal (pyqtSignal): プロット更新用のシグナル。
        plotSignal_sub (pyqtSignal): サブプロット更新用のシグナル。

    メソッド:
        __init__(self, parent=None, translator=None): DockWidgetを初期化し、翻訳を設定します。
        setup_translator(translator): 国際化のための翻訳機能を設定します。
        setup_ui(): ユーザーインターフェースを設定します。
        update_sub_items(): メインアイテム(可視化データ選択)が選択されたときにサブアイテム(評価指標選択)を更新します。
        get_current_item_value(): 現在選択されているサブアイテム(評価指標選択)の`item_value`を取得する関数。
        get_current_sub_item_value():
            現在選択されているサブアイテム(参考評価指標選択)の`item_value`を取得する関数。
        emit_plot_signal(): プロットを更新するシグナルを発信します。
        emit_subplot_signal(): サブプロットを更新するシグナルを発信します。
    """
    plotSignal = pyqtSignal(str, str)
    plotSignal_sub = pyqtSignal(str)

    def __init__(self, parent=None, translator=None):
        super().__init__(parent)
        self.setup_translator(translator)
        self.setWindowTitle(self.tr("Data Catalog"))
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.config_file = _config_file
        self.datalist_file = _datalist_file
        self.setup_ui()

    def setup_translator(self, translator):
        """
        国際化のための翻訳機能を設定します
        
        :param translator: 翻訳オブジェクト
        :type translator: QTranslator
        """
        if translator:
            QCoreApplication.installTranslator(translator)

    def setup_ui(self):
        """ユーザーインターフェースを設定します"""
        content = QWidget()
        layout = QVBoxLayout()

        self.data_items, self.years, _ = load_config(
            self.datalist_file, self.config_file
        )

        main_groupBox = QGroupBox()
        layout_main = QVBoxLayout()

        layout_main.addWidget(QLabel(self.tr('Select Visualization Data')))
        self.data_dropdown = QComboBox()
        self.data_dropdown.addItems(self.data_items.keys())
        self.data_dropdown.currentIndexChanged.connect(self.update_sub_items)
        layout_main.addWidget(self.data_dropdown)

        layout_main.addWidget(QLabel(self.tr('Select Sub Item')))
        self.sub_item_dropdown = QComboBox()
        layout_main.addWidget(self.sub_item_dropdown)

        layout_main.addWidget(QLabel(self.tr('Select Year')))
        self.year_dropdown = QComboBox()
        self.year_dropdown.addItems(self.years)
        layout_main.addWidget(self.year_dropdown)

        self.button = QPushButton(self.tr("Execute"))
        self.button.clicked.connect(self.emit_plot_signal)
        layout_main.addWidget(self.button)

        main_groupBox.setLayout(layout_main)
        layout.addWidget(main_groupBox)

        sub_groupBox = QGroupBox()
        layout_sub = QVBoxLayout()

        # 参考評価指標選択
        layout_sub.addWidget(QLabel(self.tr('Select Sub Graph Data')))
        self.sub_data_dropdown = QComboBox()
        self.sub_data_dropdown.addItems(self.data_items.keys())
        layout_sub.addWidget(self.sub_data_dropdown)

        self.button_sub = QPushButton(self.tr("Execute_sub"))
        self.button_sub.clicked.connect(self.emit_subplot_signal)
        layout_sub.addWidget(self.button_sub)

        sub_groupBox.setLayout(layout_sub)
        layout.addWidget(sub_groupBox)

        content.setLayout(layout)
        self.setWidget(content)

        self.update_sub_items()

    def update_sub_items(self):
        """メインアイテム(可視化データ選択)が選択されたときにサブアイテム(評価指標選択)を更新する関数"""
        self.sub_item_dropdown.clear()
        current_item = self.data_dropdown.currentText()
        if current_item in self.data_items:
            self.sub_item_dropdown.addItems(
                self.data_items[current_item].keys()
            )

    def get_current_item_value(self):
        """
        現在選択されているサブアイテム(評価指標選択)のitem_valueを取得する関数
        
        :return: 現在選択されているサブアイテムの値
        :rtype: str
        """
        main_item = self.data_dropdown.currentText()
        sub_item = self.sub_item_dropdown.currentText()
        return self.data_items[main_item][sub_item]

    def get_current_sub_item_value(self):
        """
        現在選択されているサブアイテム(参考評価指標選択)のitem_valueを取得する関数
        
        :return: 現在選択されているサブアイテムの値
        :rtype: str
        """
        main_item = self.sub_data_dropdown.currentText()
        return self.data_items[main_item][' ']

    def emit_plot_signal(self):
        """プロットを更新するシグナルを発信します"""
        self.plotSignal.emit(self.get_current_item_value(),
                             self.year_dropdown.currentText())

    def emit_subplot_signal(self):
        """サブプロットを更新するシグナルを発信します"""
        self.plotSignal_sub.emit(self.get_current_sub_item_value())


class GraphDock(QDockWidget):
    """
    グラフを表示するためのdockwidget
    
    このDockWidgetは、可視化グラフまたは比較グラフを表示するためのユーザーインターフェースを提供します。
    QGISアプリケーション内でフローティングまたはドッキング可能なパネルとして利用されます。

    属性:
        resize_timer (QTimer): ウィンドウのリサイズに遅延を加えてグラフサイズ調整を行うタイマー。
        content (QWidget): ダイアログのメインコンテンツ。
        layout (QVBoxLayout): メインレイアウト。
        scroll_area (QScrollArea): グラフをスクロールできる領域。
        scroll_content (QWidget): スクロール領域内のコンテンツ。
        scroll_layout (QVBoxLayout): スクロール領域のレイアウト。
        data_items (dict): 設定ファイルから読み込んだデータアイテム。
        datasets (dict): 設定ファイルから読み込んだデータセット。
        layer_coloring (LayersColoring): レイヤーの色付けを担当するオブジェクト。

    メソッド:
        __init__(self, parent=None, translator=None, title=0):
            DockWidgetを初期化し、ウィンドウタイトルを設定します。
        setup_translator(translator): 国際化のための翻訳機能を設定します。
        setup_ui(): ユーザーインターフェースを設定します。
        check_colors(): デフォルトの色と指定された色をマージする機能。
        update_plots_and_layer_coloring(data_item, year): プロットとレイヤーの色を更新します。
        update_plots(data_item): 選択されたデータ項目と年に基づいてプロットを更新します。
        title_check(text, df): テキスト内のプレースホルダを評価されたDataFrame式で置き換えます。
        plot_stacked_bar(ax, x, df, y_columns, add_line=False, colors=None,
                        change_rates=None, legends=None, bar_label_rotate=False,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            Stackedbarグラフをプロットします。
        plot_series_bar(ax, x, df, y_columns, add_line=False, colors=None,
                        change_rates=None,legends=None, bar_label_rotate=False,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            Seriesbarグラフをプロットします。
        plot_percent_bar(ax, x, df, y_columns, add_line=False, colors=None,
                        change_rates=None,legends=None, _bar_label_rotate=False,
                        is_display_bar_label=True):
            Percentbarグラフをプロットします。
        plot_years_bar(ax, df, data, colors, _change_rates,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            Yearsbarグラフをプロットします。
        check_colors_yearsbar(years_data, colors):
            Yearsbarのみにデフォルトと指定された色をマージする機能。
        get_max_value(dict_values): 最大の数値を見つける関数。
        get_min_value(dict_values): 最小の数値を見つける関数。
        check_non_numeric_values(values): リスト内の非数値の値をチェックする関数。
        add_solid_line(ax, bars, y_bases=None): 棒グラフに実線を追加する関数。
        add_dashed_line(ax, bars, y_bases=None): 棒グラフに破線を追加する関数。
        resizeEvent(event): リサイズイベントを処理する関数。
        adjust_figure_sizes(): ウィジェットのサイズに基づいて図のサイズを調整する関数。
    """
    def __init__(self, parent=None, translator=None, title=0):
        super().__init__(parent)
        self.setup_translator(translator)
        if title == 0:
            self.setWindowTitle(self.tr('Visualization Graph'))
        else:
            self.setWindowTitle(self.tr('Comparison Graph'))
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.config_file = _config_file
        self.datalist_file = _datalist_file
        self.setup_ui()

        self.resize_timer = QTimer(self)
        self.resize_timer.setSingleShot(True)
        self.resize_timer.timeout.connect(self.adjust_figure_sizes)

    def setup_translator(self, translator):
        """
        国際化のための翻訳機能を設定します
        
        :param translator: 翻訳オブジェクト
        :type translator: QTranslator
        """
        if translator:
            QCoreApplication.installTranslator(translator)

    def setup_ui(self):
        """ユーザーインターフェースを設定します"""
        self.content = QWidget()
        self.layout = QVBoxLayout()
        self.content.setLayout(self.layout)
        self.setWidget(self.content)

        self.scroll_area = QScrollArea()
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout()
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        self.scroll_area.setWidgetResizable(True)
        self.layout.addWidget(self.scroll_area)

        self.data_items, _, self.datasets = load_config(
            self.datalist_file, self.config_file
        )
        self.check_colors()
        self.layer_coloring = LayersColoring()

    def check_colors(self):
        """デフォルトの色と指定された色をマージする機能"""
        for dataset in self.datasets.values():
            for data_list in dataset:
                if data_list['type'] == 'Yearsbar':
                    continue

                if len(data_list['y']) < len(data_list['color']):
                    data_list['color'] = data_list['color'][
                        :len(data_list['y'])
                    ]
                for i in range(len(data_list['y'])):
                    if len(data_list['y']) > len(data_list['color']):
                        data_list['color'].append(_default_colors[i])
                    elif (
                        data_list['color'][i] == ''
                        or data_list['color'][i] not in _default_colors
                    ):
                        data_list['color'][i] = _default_colors[i]

    def update_plots_and_layer_coloring(self, data_item, year):
        """
        プロットとレイヤーの色を更新します
        
        :param data_item: 更新するデータ項目
        :type data_item: str
        :param year: 更新する年
        :type year: str
        """
        self.update_plots(data_item)
        self.layer_coloring.coloring(data_item, year)

    def update_plots(self, data_item):
        """
        選択されたデータ項目と年に基づいてプロットを更新します
        
        :param data_item: 更新するデータ項目
        :type data_item: str
        """
        for i in reversed(range(self.scroll_layout.count())):
            self.scroll_layout.itemAt(i).widget().setParent(None)

        if data_item in self.datasets:
            datalist = self.datasets[data_item]
            # datalist = self.datasets[data_item][year]
            for data in datalist:
                figure = Figure(figsize=(4, 3), dpi=100)
                canvas = FigureCanvas(figure)
                self.scroll_layout.addWidget(canvas)

                ax = figure.add_subplot(111)
                ax.axhline(0, color='grey', linewidth=0.8)

                df = pd.read_csv(data['path'])
                df = df.replace("―", "")
                x = None
                if data['type'] != 'Yearsbar':
                    x = df[data['x']].to_numpy()
                y_columns = data['y']
                colors = data['color']

                change_rates = []
                if data['change_rates'] and data['change_rates'] != '':
                    rate_columns = [
                        col.strip() for col in data['change_rates'].split(',')
                    ]
                    for col in rate_columns:
                        if col in df.columns:
                            change_rates.append(df[col].tolist())

                legends = []
                if (
                    data['legends'] != [''] and
                    len(data['legends']) != 0 and
                    len(data['legends']) == len(y_columns)
                ):
                    legends = data['legends']
                else:
                    legends = y_columns

                add_line = strtobool(data['addline'])
                bar_label_rotate = strtobool(data['bar_label_rotate'])
                is_display_bar_label = strtobool(data['is_display_bar_label'])

                if data['type'] == 'Stackedbar':
                    self.plot_stacked_bar(
                        ax, x, df, y_columns, bool(add_line),
                        colors, change_rates, legends,
                        bar_label_rotate=bool(bar_label_rotate),
                        label_type=data['label_type'],
                        label_format=data['label_format'],
                        is_display_bar_label=bool(is_display_bar_label)
                    )
                elif data['type'] == 'Seriesbar':
                    self.plot_series_bar(
                        ax, x, df, y_columns, bool(add_line),
                        colors, change_rates, legends,
                        bar_label_rotate=bool(bar_label_rotate),
                        label_type=data['label_type'],
                        label_format=data['label_format'],
                        is_display_bar_label=bool(is_display_bar_label)
                    )
                elif data['type'] == 'Percentbar':
                    self.plot_percent_bar(
                        ax, x, df, y_columns, bool(add_line),
                        colors, change_rates, legends,
                        _bar_label_rotate=bool(bar_label_rotate),
                        is_display_bar_label=bool(is_display_bar_label)
                    )
                elif data['type'] == 'Yearsbar':
                    self.plot_years_bar(
                        ax, df, data, colors, change_rates,
                        label_format=data['label_format'],
                        is_display_bar_label=bool(is_display_bar_label)
                    )
                else:
                    continue
                if len(data['x_name']) != 0:
                    _, x_max = ax.get_xlim()
                    y_min, _ = ax.get_ylim()
                    text_with_newlines = data['x_name'].replace(r'\n', '\n')
                    ax.text(
                        x_max + 0.1, y_min - 1.1,
                        text_with_newlines, transform=ax.transData,
                        fontsize=7, va='center'
                    )

                data['title'] = self.title_check(data['title'], df)
                ax.set_title(data['title'], fontsize=8)

                ax.tick_params(axis='both', which='major', labelsize=6)

                is_display_legend = strtobool(data['is_display_legend'])
                if is_display_legend:
                    ax.legend(
                        fontsize=6,
                        bbox_to_anchor=(0.5, -0.1),
                        loc='center',
                        borderaxespad=1,
                        ncol=3
                    )

                figure.tight_layout()
                canvas.draw()
        else:
            figure = Figure(figsize=(4, 3), dpi=100)
            canvas = FigureCanvas(figure)
            self.scroll_layout.addWidget(canvas)
            ax = figure.add_subplot(111)
            ax.text(
                0.5,
                0.5,
                self.tr("No data available"),
                ha='center',
                va='center'
            )
            canvas.draw()

        self.adjust_figure_sizes()

    @staticmethod
    def title_check(text, df):
        """
        テキスト内のプレースホルダを評価されたDataFrame式で置き換えます。

        この関数は、特定のプレースホルダにマッチするパターンを識別し、評価された結果で置き換えます。
        `df[column][-1]` や `df[column].iloc[-1]` のような式をサポートしています。

        :param text: 評価対象のテキスト。
        :type text: str
        :param df: 置き換えに使用するDataFrame。
        :type df: pandas.DataFrame

        :returns: プレースホルダが置き換えられた後のテキスト。
        :rtype: str
        """

        def evaluator(match):
            expr = match.group(1)
            try:
                result = eval(expr, {'df': df}) # pylint: disable=W0123
                if isinstance(result, (int, float)):
                    return f"{result:.2f}"
                return str(result)
            except Exception as e:
                print(f"Error evaluating {expr}: {e}")
                return match.group(0)

        patterns = [
            r'\{(df\[[^\]]+\]\[-1\])\}',
            r'\{(df\[[^\]]+\]\.iloc\[-1\])\}',
        ]

        result = text
        for pattern in patterns:
            result = re.sub(pattern, evaluator, result)
        return result

    def plot_stacked_bar(self,
                         ax, x, df, y_columns,
                         add_line: bool = False,
                         colors: list = None,
                         change_rates: list = None,
                         legends: list = None,
                         bar_label_rotate = False,
                         label_type = 'edge',
                         label_format = '1',
                         is_display_bar_label = True):
        """
        Stackedbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        """

        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        bottom = np.zeros_like(x)
        y_base = []
        for i, y_col in enumerate(y_columns):
            y = df[y_col]
            g = ax.bar(
                x,
                y,
                bottom=bottom,
                width=2,
                color=colors[i],
                label=legends[i]
            )
            rotation = 0
            if bar_label_rotate:
                rotation = 90

            if is_display_bar_label:
                if label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation
                    )

            if add_line:
                y_base = self.add_dashed_line(ax, g, y_base)
            bottom += y

            try:
                change_rate = change_rates[i]

                for j, rate in enumerate(change_rate):
                    if rate is not None and rate != "":
                        try:
                            rate_float = float(rate)
                            ax.text(
                                x[j],
                                y[j],
                                f'{rate_float:.1f}%',
                                ha='center',
                                va='bottom',
                            )
                        except ValueError:
                            pass
            except Exception:
                pass

        formatter = FuncFormatter(format_axis)
        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(x)
        ax.set_xticklabels(x)

        limit = 0
        for y_col in y_columns:
            max_value = df[y_col].max()
            limit += max_value * 1.2
        ax.set_ylim(top=limit)

    def plot_series_bar(self,
                        ax, x, df, y_columns,
                        add_line: bool = False,
                        colors: list = None,
                        change_rates: list = None,
                        legends: list = None,
                        bar_label_rotate = False,
                        label_type = 'edge',
                        label_format = '1',
                        is_display_bar_label = True):
        """
        Seriesbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        """
        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        x_array = np.arange(len(x))
        width = 0.45
        for i, y_col in enumerate(y_columns):
            y = df[y_col]
            g = ax.bar(
                x_array + i * width,
                y, width, color=colors[i],
                label=legends[i]
            )

            rotation = 0
            if bar_label_rotate:
                rotation = 90

            if is_display_bar_label:
                if label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation
                    )
            if add_line:
                _ = self.add_dashed_line(ax, g)

            try:
                change_rate = change_rates[i]

                for j, rate in enumerate(change_rate):
                    if rate is not None and rate != "":
                        try:
                            rate_float = float(rate)
                            ax.text(
                                x_array[j] + i * width,
                                y[j], f'{rate_float:.1f}%',
                                ha='center', va='bottom'
                            )
                        except ValueError:
                            pass
            except Exception:
                pass

        ax.set_xticks(x_array + width * (len(y_columns) - 1) / 2)
        ax.set_xticklabels(x)
        _ = FuncFormatter(format_axis)
        # ax.yaxis.set_major_formatter(_)
        max_value = df[y_columns].max().max()
        min_value = df[y_columns].min().min()

        if max_value > 0:
            maxlimit = max_value * 1.4
            ax.set_ylim(top=maxlimit)
        if min_value < 0:
            minlimit = max_value * 1.4
            ax.set_ylim(bottom=minlimit)

    def plot_percent_bar(self,
                        ax, x, df, y_columns,
                        add_line: bool = False,
                        colors: list = None,
                        change_rates: list = None,
                        legends: list = None,
                        _bar_label_rotate=False,
                        is_display_bar_label=True):
        """
        Percentbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param _bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type _bar_label_rotate: bool
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        """
        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []

        x_array = np.arange(len(x))
        width = 0.45
        for i, y_col in enumerate(y_columns):
            y = df[y_col].astype(float)
            y_full = np.full_like(x_array + i * width, 100)
            ax.bar(
                x_array + i * width,
                y_full,
                color='gray',
                width=width,
                alpha=0.5
            )
            g = ax.bar(
                x_array + i * width,
                y,
                width,
                color=colors[i],
                label=legends[i]
            )
            if is_display_bar_label:
                ax.bar_label(g, label_type='center', padding=2, fmt='%d%%')
            if add_line:
                _ = self.add_dashed_line(ax, g)
        if len(change_rates) > 0:
            for i, rate in enumerate(change_rates):
                if rate is not None and rate != "":
                    try:
                        rate_float = float(rate)
                        ax.text(
                            i + (width * (len(y_columns) - 1) / 2),
                            102,
                            f'{rate_float:.1f}%',
                            ha='center', va='bottom'
                        )
                    except ValueError:
                        pass
        ax.set_xticks(x_array + width * (len(y_columns) - 1) / 2)
        ax.set_xticklabels(x)
        ax.set_ylabel(', '.join(y_columns) + '%')
        limit = 120
        ax.set_ylim(top=limit)

    def plot_years_bar(self, ax, df, data, colors,
                       _change_rates,
                       label_type = 'edge',
                       label_format = '1',
                       is_display_bar_label=True
                       ):
        """
        Yearsbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param data: プロットに使用するデータ（x軸のラベル、y軸のカラム名など）。
        :type data: dict
        :param colors: 各バーの色リスト。
        :type colors: list
        :param _change_rates: 変化率リスト。
        :type _change_rates: list
        :param label_type: ラベルの位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        """
        x_labels = data['x_labels']
        x_columns = data['x'].split(',')

        years_data = {}
        for year in df['Year'].unique():
            data_values = df[df['Year'] == year][x_columns].iloc[0].tolist()
            data_values = [
                pd.to_numeric(value, errors='coerce')
                for value in data_values
            ]
            years_data[year] = data_values
        years_data = {
            year: values
            for year, values in years_data.items()
            if not (np.all(np.isnan(values)) or np.all(np.array(values) == 0))
        }

        width = 0.45
        gap = 0.2
        num_years = len(years_data)
        x = np.arange(len(x_labels)) * (width * num_years + gap)

        colors = self.check_colors_yearsbar(years_data, colors)

        for i, (year, values) in enumerate(years_data.items()):
            values_np = np.array(values)
            g = ax.bar(
                x + i * width,
                np.nan_to_num(values_np),
                width,
                label=str(year),
                color=colors[i]
            )

            if is_display_bar_label:
                if label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2
                    )

        ax.set_xticks(x + width * (len(years_data) - 1) / 2)
        ax.set_xticklabels(x_labels)
        max_value = self.get_max_value(years_data.values())
        min_value = self.get_min_value(years_data.values())

        if max_value > 0:
            maxlimit = max_value * 1.3
            ax.set_ylim(top=maxlimit)
        if min_value < 0:
            minlimit = min_value * 1.3
            ax.set_ylim(bottom=minlimit)

    @staticmethod
    def check_colors_yearsbar(years_data, colors):
        """
        Yearsbarのみにデフォルトと指定された色をマージする機能

        :param years_data: グラフのデータ（年ごとのデータ）。
        :type years_data: dict
        :param colors: 指定された色リスト。
        :type colors: list

        :returns: 色リスト（デフォルト色を含む）。
        :rtype: list
        """
        num_years = len(years_data)
        if not colors:
            return [
                _default_colors[i % len(_default_colors)]
                for i in range(num_years)
            ]
        while len(colors) < num_years:
            colors.append(_default_colors[len(colors) % len(_default_colors)])
        for i in range(num_years):
            if colors[i] == '' or colors[i] not in _default_colors:
                colors[i] = _default_colors[i % len(_default_colors)]

        return colors[:num_years]

    @staticmethod
    def get_max_value(dict_values):
        """
        最大の数値を見つける関数

        :param dict_values: 数値を含むリストまたは辞書。
        :type dict_values: list, dict

        :returns: 最大値。
        :rtype: float
        """
        try:
            if not hasattr(dict_values, '__iter__'):
                return 0

            max_value = float('-inf')
            for sublist in dict_values:
                if isinstance(sublist, (list, tuple)):
                    values = [
                        float(x) for x in sublist
                        if str(x).replace('.', '', 1).isdigit()
                    ]
                    if values:
                        max_value = max(max_value, *values)

            return max_value if max_value != float('-inf') else 0

        except Exception as e:
            print(f"Error processing dictionary values: {e}")
            return 0

    @staticmethod
    def get_min_value(dict_values):
        """
        最小の数値を見つける関数

        :param dict_values: 数値を含むリストまたは辞書。
        :type dict_values: list, dict

        :returns: 最小値。
        :rtype: float
        """
        try:
            if not hasattr(dict_values, '__iter__'):
                return 0

            min_value = float('inf')
            for sublist in dict_values:
                if isinstance(sublist, (list, tuple)):
                    values = []
                    for x in sublist:
                        try:
                            str_x = str(x).replace('-', '', 1)
                            if str_x.replace('.', '', 1).isdigit():
                                values.append(float(x))
                        except ValueError:
                            continue

                    if values:
                        min_value = min(min_value, *values)

            return min_value if min_value != float('inf') else 0

        except Exception as e:
            print(f"Error processing dictionary values: {e}")
            return 0

    def check_non_numeric_values(self, values):
        """
        リスト内の非数値の値をチェックする関数

        :param values: チェックする値のリスト。
        :type values: list

        :returns: リストに非数値が含まれている場合はTrue、そうでなければFalse。
        :rtype: bool
        """
        for value in values:
            if not isinstance(value, (int, float)):
                return True
        return False

    def add_solid_line(self, ax, bars, y_bases=None):
        """
        棒グラフに実線を追加する関数

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param bars: 実線を追加するバーのリスト。
        :type bars: list
        :param y_bases: 実線のy座標の基準（省略可能）。
        :type y_bases: list, optional

        :returns: 実線のy座標リスト。
        :rtype: list
        """
        if y_bases is None:
            y_bases = []
        return_list = []
        y2 = 0
        if len(y_bases) == 0:
            y_bases = [0 for i in range(len(bars))]
        for i in range(len(bars) - 1):
            current_bar = bars[i]
            next_bar = bars[i + 1]

            x1 = current_bar.get_x() + current_bar.get_width()
            y1 = y_bases[i] + current_bar.get_height()
            x2 = next_bar.get_x()
            y2 = y_bases[i + 1] + next_bar.get_height()
            ax.plot(
                [x1, x2], [y1, y2], color='grey', linestyle='-', linewidth=0.5
            )

            return_list.append(y1)
        return_list.append(y2)

        return return_list

    def add_dashed_line(self, ax, bars, y_bases=None):
        """
        棒グラフに破線を追加する関数

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param bars: 破線を追加するバーのリスト。
        :type bars: list
        :param y_bases: 破線のy座標の基準（省略可能）。
        :type y_bases: list, optional

        :returns: 破線のy座標リスト。
        :rtype: list
        """
        if y_bases is None:
            y_bases = []
        return_list = []
        y2 = 0
        if len(y_bases) == 0:
            y_bases = [0 for i in range(len(bars))]
        for i in range(len(bars) - 1):
            current_bar = bars[i]
            next_bar = bars[i + 1]

            x1 = current_bar.get_x() + current_bar.get_width()
            y1 = y_bases[i] + current_bar.get_height()
            x2 = next_bar.get_x()
            y2 = y_bases[i + 1] + next_bar.get_height()
            ax.plot([x1, x2], [y1, y2], 'k--', linewidth=0.5)

            return_list.append(y1)
        return_list.append(y2)

        return return_list

    def resizeEvent(self, event):
        """
        リサイズイベントを処理する関数

        :param event: イベント情報。
        :type event: QResizeEvent
        """
        super().resizeEvent(event)
        self.resize_timer.start(200)

    def adjust_figure_sizes(self):
        """ウィジェットのサイズに基づいて図のサイズを調整する関数"""
        width = self.scroll_area.viewport().width() - 20
        height = int(width * 3 / 4)

        for i in range(self.scroll_layout.count()):
            item = self.scroll_layout.itemAt(i)
            if isinstance(item.widget(), FigureCanvas):
                canvas = item.widget()
                figure = canvas.figure
                width_inches = width / figure.dpi
                height_inches = height / figure.dpi
                figure.set_size_inches(width_inches, height_inches)
                canvas.setFixedSize(width, height)
                figure.tight_layout()
